#include <algorithm>
#include <string>
#include <vector>
#include <string>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <cstring>
#include <cstdlib>
#include <vector>

#include "boost/algorithm/string.hpp"

#include "caffe/caffe.hpp"
#include "caffe/layers/memory_data_layer.hpp"

#include "caffe_mobile.hpp"

#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>

using std::clock;
using std::clock_t;
using std::string;
using std::vector;

using caffe::Blob;
using caffe::Caffe;
using caffe::Datum;
using caffe::Net;
using caffe::MemoryDataLayer;

#define UNASSIGNED 0

using namespace std;
using namespace cv;

namespace caffe {

    const int NUMRECT_DIM = 20;
    const int NUMRECT_PIX = NUMRECT_DIM * NUMRECT_DIM;
    
    
    bool FindUnassignedLocation(int **grid, int &row, int &col);
    bool isSafe(int **grid, int row, int col, int num);
    
    bool solve(int **grid)
    {
        char valueExists[9];
        
        // check rows
        for (int i = 0; i < 9; i++) {
            memset(valueExists, 0, 9 * sizeof(char));
            for (int j = 0; j < 9; j++) {
                int value = grid[i][j];
                if (!value) continue;
                char* exist = &valueExists[value - 1];
                if (*exist) {
                    return false;
                }
                *exist = 1;
            }
        }
        // check cols
        for (int j = 0; j < 9; j++) {
            memset(valueExists, 0, 9 * sizeof(char));
            for (int i = 0; i < 9; i++) {
                int value = grid[i][j];
                if (!value) continue;
                char* exist = &valueExists[value - 1];
                if (*exist) {
                    return false;
                }
                *exist = 1;
            }
        }
        // check blocks
        for (int a = 0; a < 3; a++) {
            for (int b = 0; b < 3; b++) {
                memset(valueExists, 0, 9 * sizeof(char));
                for (int i = 3 * a; i < 3 * (a + 1); i++) {
                    for (int j = 3 * b; j < 3 * (b + 1); j++) {
                        int value = grid[i][j];
                        if (!value) continue;
                        char* exist = &valueExists[value - 1];
                        if (*exist) {
                            return false;
                        }
                        *exist = 1;
                    }
                }
            }
        }
        
        
        int row, col;
        if (!FindUnassignedLocation(grid, row, col))
            return true;
        for (int num = 1; num <= 9; num++)
        {
            if (isSafe(grid, row, col, num))
            {
                grid[row][col] = num;
                if (solve(grid))
                    return true;
                grid[row][col] = UNASSIGNED;
            }
        }
        return false;
    }
    
    bool FindUnassignedLocation(int **grid, int &row, int &col)
    {
        for (row = 0; row < 9; row++)
            for (col = 0; col < 9; col++)
                if (grid[row][col] == UNASSIGNED)
                    return true;
        return false;
    }
    
    bool UsedInRow(int **grid, int row, int num)
    {
        for (int col = 0; col < 9; col++)
            if (grid[row][col] == num)
                return true;
        return false;
    }
    
    bool UsedInCol(int **grid, int col, int num)
    {
        for (int row = 0; row < 9; row++)
            if (grid[row][col] == num)
                return true;
        return false;
    }
    
    bool UsedInBox(int **grid, int boxStartRow, int boxStartCol, int num)
    {
        for (int row = 0; row < 3; row++)
            for (int col = 0; col < 3; col++)
                if (grid[row + boxStartRow][col + boxStartCol] == num)
                    return true;
        return false;
    }
    
    bool isSafe(int **grid, int row, int col, int num)
    {
        return !UsedInRow(grid, row, num) && !UsedInCol(grid, col, num) &&
        !UsedInBox(grid, row - row % 3, col - col % 3, num);
    }
    
    void drawLine(Vec2f line, Mat &img, Scalar rgb = CV_RGB(0,0,255))
    {
        if(line[1]!=0)
        {
            float m = -1/tan(line[1]);
            
            float c = line[0]/sin(line[1]);
            
            cv::line(img, Point(0, c), Point(img.size().width, m*img.size().width+c), rgb);
        }
        else
        {
            cv::line(img, Point(line[0], 0), Point(line[0], img.size().height), rgb);
        }
        
    }
    
    void mergeRelatedLines(vector<Vec2f> *lines, Mat &img)
    {
        vector<Vec2f>::iterator current;
        for(current=lines->begin();current!=lines->end();current++)
        {
            if((*current)[0]==0 && (*current)[1]==-100) continue;
            float p1 = (*current)[0];
            float theta1 = (*current)[1];
            Point pt1current, pt2current;
            if(theta1>CV_PI*45/180 && theta1<CV_PI*135/180)
            {
                pt1current.x=0;
                
                pt1current.y = p1/sin(theta1);
                
                pt2current.x=img.size().width;
                pt2current.y=-pt2current.x/tan(theta1) + p1/sin(theta1);
            }
            else
            {
                pt1current.y=0;
                
                pt1current.x=p1/cos(theta1);
                
                pt2current.y=img.size().height;
                pt2current.x=-pt2current.y/tan(theta1) + p1/cos(theta1);
                
            }
            vector<Vec2f>::iterator    pos;
            for(pos=lines->begin();pos!=lines->end();pos++)
            {
                if(*current==*pos) continue;
                if(fabs((*pos)[0]-(*current)[0])<20 && fabs((*pos)[1]-(*current)[1])<CV_PI*10/180)
                {
                    float p = (*pos)[0];
                    float theta = (*pos)[1];
                    Point pt1, pt2;
                    if((*pos)[1]>CV_PI*45/180 && (*pos)[1]<CV_PI*135/180)
                    {
                        pt1.x=0;
                        pt1.y = p/sin(theta);
                        pt2.x=img.size().width;
                        pt2.y=-pt2.x/tan(theta) + p/sin(theta);
                    }
                    else
                    {
                        pt1.y=0;
                        pt1.x=p/cos(theta);
                        pt2.y=img.size().height;
                        pt2.x=-pt2.y/tan(theta) + p/cos(theta);
                    }
                    if(((double)(pt1.x-pt1current.x)*(pt1.x-pt1current.x) + (pt1.y-pt1current.y)*(pt1.y-pt1current.y)<64*64) &&
                       ((double)(pt2.x-pt2current.x)*(pt2.x-pt2current.x) + (pt2.y-pt2current.y)*(pt2.y-pt2current.y)<64*64))
                    {
                        // Merge the two
                        (*current)[0] = ((*current)[0]+(*pos)[0])/2;
                        
                        (*current)[1] = ((*current)[1]+(*pos)[1])/2;
                        
                        (*pos)[0]=0;
                        (*pos)[1]=-100;
                    }
                }
            }
        }
    }
    
    int CaffeMobile::getImage(const string &image_file, int **puzzle)
    {
        char digit_1[30*26] = {0, 0, 3, 0, 1, 0, 0, 1, 0, 140, 253, 195, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 1, 1, 0, 0, 142, 231, 255, 242, 186, 21, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 146, 230, 253, 255, 254, 250, 173, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 1, 1, 23, 136, 233, 255, 253, 255, 255, 254, 255, 59, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 43, 103, 124, 255, 255, 251, 254, 255, 254, 255, 255, 54, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 41, 160, 255, 255, 254, 255, 255, 255, 252, 254, 249, 191, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 155, 255, 253, 254, 255, 255, 252, 255, 255, 255, 234, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 158, 254, 255, 255, 255, 255, 255, 254, 255, 254, 235, 19, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 22, 138, 254, 255, 255, 255, 255, 255, 255, 254, 235, 20, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 29, 68, 97, 255, 255, 255, 250, 253, 255, 235, 18, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 3, 15, 101, 232, 255, 255, 255, 255, 236, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 0, 115, 218, 254, 254, 254, 235, 20, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 3, 177, 253, 255, 255, 236, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 0, 2, 2, 0, 0, 173, 255, 255, 255, 238, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 0, 0, 4, 0, 177, 255, 251, 251, 235, 21, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 2, 0, 0, 176, 253, 255, 255, 233, 23, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 255, 255, 255, 235, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 254, 255, 255, 230, 20, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 176, 252, 255, 255, 237, 19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 177, 255, 254, 255, 236, 20, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 116, 219, 253, 255, 233, 21, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 109, 225, 243, 192, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 95, 199, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        
        char digit_2[30*26] = {2, 0, 0, 2, 0, 2, 1, 214, 255, 253, 255, 254, 255, 253, 255, 253, 254, 179, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 1, 29, 202, 251, 254, 255, 250, 255, 255, 252, 254, 255, 255, 238, 171, 0, 1, 0, 2, 0, 0, 0, 1, 1, 0, 0, 53, 183, 255, 252, 254, 254, 255, 255, 255, 255, 255, 253, 254, 254, 244, 172, 27, 0, 0, 0, 0, 0, 0, 2, 0, 65, 174, 253, 255, 255, 255, 181, 119, 118, 117, 120, 118, 206, 255, 255, 253, 255, 151, 42, 2, 0, 0, 0, 1, 0, 1, 117, 252, 254, 255, 255, 183, 71, 1, 0, 0, 0, 0, 93, 196, 255, 254, 255, 255, 77, 0, 0, 0, 0, 1, 0, 1, 119, 255, 255, 255, 194, 55, 2, 1, 0, 0, 0, 0, 2, 119, 255, 254, 254, 255, 83, 0, 0, 0, 0, 0, 0, 19, 136, 253, 253, 216, 37, 5, 0, 0, 1, 0, 1, 0, 0, 101, 233, 249, 255, 254, 74, 0, 2, 0, 0, 0, 0, 158, 255, 255, 216, 2, 0, 0, 1, 2, 1, 0, 0, 2, 0, 0, 76, 255, 252, 255, 80, 0, 0, 0, 0, 1, 0, 21, 138, 186, 28, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 77, 255, 255, 253, 80, 0, 2, 0, 0, 0, 2, 0, 27, 48, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 79, 253, 255, 255, 77, 0, 0, 0, 0, 0, 0, 2, 3, 2, 1, 0, 1, 0, 4, 0, 0, 0, 2, 0, 0, 70, 184, 255, 255, 255, 81, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 2, 71, 183, 255, 253, 255, 252, 78, 0, 1, 0, 0, 0, 1, 0, 0, 2, 0, 2, 0, 2, 0, 0, 4, 0, 1, 65, 191, 252, 255, 255, 255, 185, 53, 0, 0, 0, 0, 1, 1, 0, 1, 2, 0, 0, 3, 0, 2, 0, 0, 3, 44, 210, 255, 255, 255, 251, 253, 40, 0, 3, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 3, 5, 36, 237, 255, 255, 255, 251, 251, 243, 37, 0, 2, 2, 0, 0, 0, 0, 1, 0, 2, 0, 3, 0, 1, 2, 0, 54, 238, 255, 255, 254, 254, 255, 218, 17, 2, 3, 0, 0, 0, 0, 2, 0, 1, 2, 0, 0, 1, 0, 0, 113, 203, 215, 255, 254, 255, 253, 255, 190, 43, 2, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 3, 0, 142, 174, 212, 255, 255, 255, 254, 255, 255, 177, 60, 0, 1, 1, 1, 0, 0, 0, 0, 0, 5, 0, 0, 0, 22, 134, 239, 253, 255, 255, 252, 254, 255, 149, 116, 63, 0, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 33, 125, 255, 253, 255, 254, 254, 231, 156, 151, 37, 2, 0, 2, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 33, 123, 253, 255, 255, 254, 255, 228, 146, 0, 0, 0, 0, 0, 0, 0, 0, 2, 1, 0, 1, 0, 0, 0, 6, 18, 134, 255, 255, 255, 255, 255, 254, 157, 1, 0, 0, 3, 1, 2, 0, 2, 0, 0, 0, 2, 0, 0, 0, 4, 0, 157, 255, 254, 255, 252, 253, 255, 255, 157, 1, 0, 3, 0, 0, 1, 0, 0, 0, 3, 0, 2, 0, 0, 0, 0, 0, 157, 255, 254, 255, 252, 255, 253, 255, 154, 0, 1, 0, 0, 2, 0, 0, 5, 0, 0, 2, 0, 1, 0, 0, 0, 0, 158, 255, 252, 255, 255, 255, 255, 255, 229, 145, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 2, 152, 255, 255, 253, 252, 255, 254, 255, 255, 231, 155, 153, 151, 154, 152, 154, 152, 157, 153, 46, 0, 0, 0, 0, 0, 3, 157, 254, 254, 255, 255, 254, 255, 252, 253, 255, 250, 255, 255, 254, 255, 253, 254, 255, 255, 159, 60, 0, 0, 0, 1, 0, 104, 209, 255, 255, 255, 252, 255, 255, 255, 253, 255, 255, 255, 255, 255, 255, 254, 255, 253, 255, 116, 0, 0, 0, 0, 0, 1, 98, 215, 255, 255, 255, 251, 255, 255, 255, 255, 252, 254, 255, 253, 255, 255, 250, 255, 222, 92, 1, 0, 0, 2, 0, 1, 0, 78, 252, 255, 253, 255, 255, 252, 254, 255, 255, 255, 254, 255, 253, 255, 255, 253, 81, 1, 0, 0, 0};
        
        char digit_3[30*26] = {0, 2, 0, 0, 1, 0, 0, 1, 2, 137, 255, 253, 254, 255, 59, 0, 2, 0, 0, 2, 0, 0, 4, 0, 0, 0, 1, 3, 3, 0, 0, 35, 204, 205, 201, 230, 254, 255, 255, 254, 219, 204, 201, 145, 1, 0, 1, 4, 0, 2, 0, 0, 0, 0, 0, 1, 55, 181, 254, 254, 255, 255, 255, 250, 255, 255, 255, 255, 255, 224, 145, 0, 1, 0, 0, 1, 0, 0, 4, 1, 0, 65, 169, 255, 255, 254, 252, 251, 254, 255, 255, 252, 254, 255, 254, 255, 237, 133, 21, 0, 4, 0, 0, 0, 0, 0, 2, 117, 255, 255, 252, 255, 255, 255, 214, 154, 161, 246, 255, 255, 254, 253, 254, 255, 124, 33, 0, 1, 0, 0, 0, 1, 42, 153, 255, 255, 254, 255, 255, 217, 115, 0, 12, 176, 188, 228, 255, 255, 255, 251, 255, 77, 0, 1, 0, 0, 1, 1, 157, 255, 252, 254, 255, 253, 234, 100, 0, 0, 0, 1, 0, 134, 235, 255, 255, 255, 254, 77, 1, 0, 0, 0, 0, 1, 155, 255, 255, 255, 255, 255, 77, 1, 0, 1, 1, 0, 3, 0, 119, 255, 252, 255, 255, 79, 0, 0, 0, 0, 0, 2, 156, 255, 255, 255, 252, 70, 8, 2, 0, 1, 0, 0, 2, 0, 114, 255, 254, 255, 255, 78, 0, 0, 0, 0, 2, 0, 41, 154, 255, 223, 72, 10, 1, 1, 0, 0, 0, 2, 0, 0, 122, 250, 255, 252, 253, 78, 5, 2, 0, 0, 0, 1, 2, 47, 102, 89, 0, 0, 0, 0, 0, 1, 4, 2, 0, 93, 199, 255, 255, 253, 255, 76, 2, 0, 0, 0, 2, 0, 1, 0, 0, 2, 4, 1, 0, 2, 0, 0, 1, 0, 93, 205, 255, 255, 252, 255, 254, 77, 0, 2, 0, 0, 0, 1, 0, 0, 1, 0, 0, 2, 0, 0, 34, 87, 85, 87, 214, 254, 255, 254, 255, 252, 184, 53, 0, 0, 0, 0, 0, 4, 0, 1, 1, 4, 0, 0, 1, 25, 128, 255, 254, 254, 255, 255, 255, 254, 255, 255, 38, 1, 0, 2, 0, 0, 0, 1, 0, 3, 0, 0, 4, 0, 0, 131, 244, 251, 255, 255, 255, 255, 255, 255, 255, 252, 38, 2, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0, 1, 0, 0, 7, 110, 255, 255, 255, 251, 255, 255, 255, 255, 255, 41, 0, 0, 2, 0, 0, 0, 2, 0, 4, 0, 2, 1, 0, 1, 2, 17, 99, 255, 255, 255, 255, 254, 255, 255, 255, 210, 65, 1, 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 1, 22, 82, 83, 88, 186, 255, 255, 255, 255, 255, 78, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 1, 2, 1, 0, 0, 3, 1, 0, 76, 183, 253, 251, 255, 253, 174, 64, 1, 0, 0, 1, 2, 0, 3, 0, 0, 0, 0, 0, 0, 2, 1, 1, 0, 0, 1, 70, 186, 255, 254, 255, 254, 114, 2, 0, 0, 3, 0, 0, 30, 50, 1, 3, 0, 0, 2, 1, 0, 0, 2, 0, 0, 0, 78, 255, 254, 254, 255, 119, 2, 0, 0, 0, 3, 21, 136, 186, 30, 0, 1, 0, 2, 0, 0, 0, 0, 0, 3, 0, 74, 255, 255, 254, 254, 112, 2, 0, 0, 2, 3, 156, 254, 254, 216, 3, 0, 0, 2, 0, 2, 1, 0, 3, 0, 1, 79, 253, 255, 255, 253, 123, 0, 0, 0, 1, 0, 157, 255, 254, 252, 219, 34, 0, 0, 0, 1, 0, 2, 0, 1, 0, 78, 255, 254, 255, 253, 117, 1, 0, 0, 1, 1, 157, 253, 255, 253, 255, 40, 1, 0, 0, 3, 0, 1, 2, 0, 87, 206, 255, 255, 255, 126, 32, 0, 0, 0, 0, 0, 160, 255, 255, 255, 253, 168, 47, 0, 1, 2, 3, 1, 0, 94, 202, 255, 253, 255, 252, 80, 0, 0, 0, 0, 0, 0, 84, 191, 254, 254, 253, 255, 162, 119, 120, 117, 117, 119, 119, 204, 253, 255, 249, 255, 155, 40, 1, 1, 0, 0, 1, 0, 0, 80, 195, 255, 254, 255, 254, 254, 255, 255, 253, 255, 255, 255, 255, 254, 246, 168, 25, 2, 0, 0, 0, 0, 1, 0, 0, 2, 61, 212, 255, 254, 255, 255, 253, 255, 254, 255, 254, 253, 252, 239, 172, 0, 0, 1, 2, 0, 0, 0, 0, 6, 2, 0, 1, 37, 255, 255, 255, 253, 254, 255, 255, 255, 252, 255, 255, 178, 0, 2, 0, 0, 0, 2, 0, 0};
        
        char digit_4[30*26] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 1, 184, 255, 186, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0, 1, 0, 0, 0, 4, 32, 172, 235, 255, 235, 175, 29, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 3, 51, 156, 249, 255, 252, 253, 246, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 51, 152, 254, 254, 255, 255, 254, 242, 52, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 167, 255, 255, 255, 254, 255, 254, 246, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 2, 0, 0, 168, 253, 254, 253, 255, 253, 255, 244, 52, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 21, 156, 230, 255, 255, 255, 255, 255, 255, 245, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 41, 144, 242, 254, 255, 255, 253, 255, 255, 255, 247, 48, 1, 0, 0, 0, 3, 0, 0, 1, 0, 0, 2, 0, 0, 45, 137, 255, 254, 255, 254, 255, 253, 255, 253, 255, 247, 46, 2, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 1, 24, 156, 255, 255, 255, 238, 230, 233, 254, 255, 255, 253, 244, 50, 0, 0, 0, 3, 0, 0, 0, 0, 0, 4, 0, 8, 185, 246, 253, 255, 255, 105, 25, 72, 242, 252, 255, 255, 244, 50, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1, 13, 201, 255, 254, 234, 96, 27, 1, 15, 77, 208, 251, 255, 243, 53, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 33, 133, 234, 254, 253, 226, 29, 1, 0, 0, 0, 185, 255, 253, 249, 46, 0, 0, 0, 1, 0, 0, 2, 2, 0, 40, 123, 252, 255, 254, 225, 163, 22, 0, 3, 1, 2, 187, 254, 255, 246, 46, 4, 0, 0, 0, 0, 0, 1, 0, 4, 123, 255, 255, 255, 255, 169, 0, 0, 1, 0, 0, 0, 183, 255, 255, 242, 50, 0, 0, 0, 1, 2, 0, 2, 1, 0, 129, 255, 255, 252, 254, 167, 1, 2, 0, 1, 0, 2, 186, 254, 253, 248, 48, 0, 0, 0, 1, 1, 0, 4, 0, 131, 216, 255, 255, 252, 255, 167, 0, 3, 0, 1, 34, 171, 236, 251, 255, 253, 193, 75, 0, 0, 0, 2, 2, 0, 2, 187, 255, 255, 254, 255, 255, 208, 114, 13, 1, 55, 153, 249, 255, 255, 255, 255, 255, 177, 82, 1, 3, 0, 0, 19, 73, 207, 252, 255, 255, 254, 252, 255, 232, 97, 75, 152, 255, 253, 255, 255, 254, 253, 253, 255, 193, 76, 0, 2, 0, 47, 245, 255, 255, 255, 254, 255, 253, 254, 255, 255, 255, 255, 255, 255, 254, 255, 255, 254, 255, 252, 253, 254, 0, 0, 0, 51, 248, 254, 253, 253, 253, 254, 255, 253, 255, 255, 255, 254, 255, 254, 255, 252, 253, 253, 255, 255, 255, 255, 1, 1, 0, 14, 72, 204, 255, 255, 255, 255, 255, 255, 252, 253, 255, 255, 255, 255, 255, 255, 255, 253, 255, 255, 253, 255, 2, 0, 1, 0, 2, 97, 126, 125, 125, 126, 125, 131, 130, 127, 130, 179, 250, 255, 252, 255, 255, 255, 255, 252, 210, 128, 0, 0, 1, 0, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0, 0, 77, 195, 251, 255, 255, 253, 255, 252, 213, 118, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 44, 222, 249, 252, 255, 254, 233, 97, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 23, 194, 255, 253, 247, 72, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 188, 253, 255, 244, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 184, 255, 253, 245, 47, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 130, 219, 233, 171, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 130, 184, 0, 1, 1, 0, 0};
        
        char digit_5[30*26] = {0, 3, 0, 1, 33, 238, 255, 255, 255, 254, 255, 255, 254, 255, 254, 255, 255, 255, 141, 2, 0, 0, 3, 0, 0, 0, 0, 0, 1, 61, 204, 252, 254, 255, 254, 255, 255, 253, 255, 255, 255, 253, 255, 255, 225, 142, 2, 0, 0, 2, 0, 0, 4, 0, 4, 83, 251, 255, 255, 254, 255, 254, 255, 255, 253, 255, 253, 255, 254, 253, 190, 80, 0, 0, 3, 0, 0, 0, 0, 0, 1, 83, 255, 252, 255, 255, 255, 235, 149, 153, 150, 145, 152, 146, 148, 153, 81, 0, 2, 0, 1, 0, 0, 0, 2, 1, 0, 79, 255, 255, 255, 255, 235, 159, 5, 0, 2, 3, 0, 0, 0, 2, 1, 0, 0, 1, 0, 3, 0, 0, 0, 0, 2, 86, 254, 254, 252, 243, 146, 0, 2, 0, 0, 0, 0, 3, 2, 0, 2, 1, 0, 1, 0, 0, 0, 0, 2, 0, 0, 85, 255, 254, 255, 123, 13, 3, 1, 0, 1, 0, 0, 0, 3, 0, 0, 0, 0, 0, 2, 1, 0, 0, 0, 0, 1, 81, 255, 255, 255, 113, 1, 0, 0, 1, 1, 0, 4, 0, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0, 0, 2, 2, 79, 255, 255, 253, 197, 94, 1, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 2, 0, 2, 0, 0, 0, 0, 0, 54, 157, 255, 254, 255, 255, 200, 106, 105, 109, 105, 105, 109, 104, 21, 0, 4, 2, 0, 0, 0, 1, 0, 0, 0, 4, 134, 253, 253, 255, 252, 255, 254, 255, 252, 255, 255, 255, 253, 249, 95, 64, 33, 0, 0, 3, 0, 1, 0, 0, 1, 0, 129, 255, 255, 250, 255, 255, 255, 255, 255, 255, 252, 255, 253, 255, 254, 255, 152, 13, 0, 0, 2, 0, 0, 0, 0, 0, 134, 255, 253, 255, 254, 255, 250, 255, 255, 255, 255, 255, 255, 252, 255, 254, 245, 176, 1, 0, 0, 5, 0, 0, 0, 0, 133, 255, 255, 255, 255, 254, 255, 216, 67, 64, 179, 254, 255, 255, 255, 253, 255, 241, 177, 26, 1, 0, 0, 0, 0, 2, 56, 153, 255, 252, 255, 174, 106, 89, 4, 3, 60, 106, 136, 254, 255, 255, 252, 255, 236, 35, 0, 3, 0, 0, 2, 0, 0, 50, 147, 150, 150, 65, 0, 0, 0, 0, 3, 0, 33, 151, 236, 255, 255, 255, 247, 125, 37, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 1, 0, 1, 4, 158, 233, 255, 253, 255, 254, 84, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 255, 255, 253, 252, 88, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 2, 159, 254, 255, 254, 255, 82, 0, 0, 0, 1, 1, 2, 0, 0, 2, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 164, 255, 254, 254, 255, 84, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 162, 253, 254, 255, 255, 84, 0, 0, 0, 0, 2, 0, 37, 106, 107, 25, 2, 0, 1, 2, 1, 0, 1, 0, 0, 3, 163, 255, 255, 252, 255, 79, 2, 0, 0, 1, 0, 32, 127, 253, 253, 117, 24, 0, 0, 0, 1, 0, 0, 0, 4, 50, 184, 255, 255, 255, 200, 65, 0, 0, 0, 0, 2, 131, 254, 255, 255, 251, 128, 14, 2, 0, 1, 1, 0, 7, 25, 217, 255, 254, 254, 241, 31, 1, 0, 0, 0, 1, 0, 133, 253, 255, 252, 255, 243, 149, 0, 2, 1, 0, 0, 49, 234, 251, 255, 255, 254, 238, 34, 1, 0, 0, 0, 1, 1, 133, 254, 253, 255, 253, 255, 231, 192, 191, 36, 114, 190, 206, 255, 255, 253, 254, 255, 243, 34, 0, 0, 0, 0, 1, 0, 54, 161, 253, 253, 255, 255, 255, 254, 255, 173, 212, 255, 254, 255, 253, 255, 253, 216, 101, 17, 1, 0, 0, 0, 0, 0, 2, 46, 152, 149, 224, 255, 255, 255, 251, 255, 255, 253, 255, 253, 255, 255, 209, 108, 0, 0, 0, 1, 0, 0, 0, 6, 0, 0, 0, 1, 147, 191, 214, 254, 255, 255, 255, 251, 241, 194, 191, 191, 106, 3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 1, 3, 0, 0, 0, 95, 253, 253, 255, 255, 255, 202, 0, 0, 0, 0, 2, 0, 0, 1, 1, 0, 0};
        
        char digit_6[30*26] = {1, 0, 3, 0, 2, 0, 0, 2, 0, 0, 96, 255, 254, 255, 255, 98, 1, 0, 0, 0, 1, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 174, 207, 203, 224, 253, 251, 255, 255, 220, 200, 207, 173, 1, 0, 2, 0, 0, 0, 0, 0, 1, 1, 3, 0, 25, 174, 242, 253, 254, 253, 255, 255, 253, 254, 255, 255, 255, 240, 168, 25, 0, 2, 0, 0, 0, 0, 0, 0, 0, 43, 152, 255, 254, 255, 255, 254, 255, 251, 254, 255, 251, 255, 253, 254, 255, 156, 40, 2, 0, 0, 0, 0, 0, 5, 47, 150, 255, 250, 255, 255, 252, 255, 229, 150, 156, 231, 255, 255, 254, 255, 254, 254, 79, 0, 0, 0, 0, 2, 2, 0, 116, 255, 251, 255, 255, 253, 255, 231, 141, 4, 0, 143, 228, 255, 255, 255, 255, 253, 77, 3, 1, 0, 0, 0, 0, 0, 119, 254, 255, 255, 253, 255, 238, 133, 0, 1, 3, 0, 135, 236, 255, 252, 254, 224, 70, 0, 1, 0, 0, 0, 0, 2, 116, 255, 255, 255, 255, 254, 118, 1, 0, 0, 0, 0, 2, 119, 254, 255, 255, 38, 2, 0, 0, 0, 0, 1, 0, 137, 238, 252, 255, 255, 255, 103, 13, 2, 1, 0, 1, 1, 1, 17, 34, 34, 34, 6, 0, 0, 1, 0, 0, 0, 4, 154, 254, 255, 255, 255, 255, 207, 90, 0, 0, 5, 0, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 157, 255, 255, 253, 254, 254, 254, 198, 154, 153, 151, 155, 153, 153, 153, 106, 1, 3, 0, 0, 0, 2, 0, 0, 1, 0, 155, 255, 254, 255, 255, 255, 255, 255, 255, 255, 254, 255, 254, 255, 255, 212, 101, 0, 0, 1, 0, 0, 0, 0, 1, 0, 159, 255, 254, 255, 255, 254, 253, 255, 255, 255, 254, 254, 255, 254, 255, 255, 227, 85, 15, 0, 0, 2, 0, 0, 0, 0, 157, 255, 253, 254, 254, 255, 254, 255, 252, 254, 255, 255, 255, 255, 255, 252, 255, 255, 78, 15, 1, 0, 0, 0, 2, 0, 156, 254, 254, 255, 255, 255, 254, 254, 246, 242, 239, 235, 234, 247, 254, 255, 250, 255, 255, 81, 0, 4, 0, 0, 0, 0, 158, 255, 255, 255, 253, 255, 255, 255, 166, 14, 17, 19, 18, 163, 255, 255, 255, 254, 255, 76, 3, 0, 0, 0, 3, 0, 157, 255, 253, 255, 255, 255, 253, 145, 31, 2, 1, 0, 0, 30, 144, 255, 255, 254, 255, 220, 92, 1, 0, 0, 0, 2, 156, 255, 255, 255, 255, 254, 139, 40, 0, 0, 0, 3, 0, 2, 37, 137, 254, 255, 253, 255, 121, 0, 0, 0, 3, 0, 156, 253, 255, 253, 255, 255, 76, 1, 0, 0, 2, 0, 0, 0, 3, 80, 253, 253, 255, 250, 117, 1, 0, 0, 0, 2, 163, 254, 255, 255, 253, 170, 46, 2, 0, 0, 0, 0, 4, 0, 0, 78, 255, 254, 255, 255, 116, 1, 0, 0, 0, 0, 153, 255, 253, 255, 255, 97, 22, 0, 0, 3, 0, 0, 1, 0, 1, 76, 255, 255, 255, 253, 119, 0, 0, 0, 1, 1, 160, 255, 255, 252, 255, 254, 78, 0, 0, 0, 1, 0, 1, 0, 14, 103, 255, 255, 254, 255, 120, 1, 0, 0, 0, 0, 156, 254, 252, 255, 255, 255, 81, 0, 1, 1, 0, 5, 0, 0, 121, 253, 255, 252, 255, 254, 116, 0, 0, 0, 0, 5, 17, 137, 255, 253, 255, 255, 229, 105, 0, 2, 0, 0, 0, 137, 235, 255, 254, 255, 254, 255, 116, 1, 0, 0, 0, 3, 0, 118, 255, 255, 255, 254, 255, 218, 114, 4, 0, 0, 146, 228, 255, 253, 255, 255, 254, 126, 32, 1, 0, 0, 2, 1, 0, 47, 148, 254, 254, 255, 254, 255, 213, 155, 150, 157, 229, 255, 253, 255, 253, 255, 255, 80, 0, 0, 0, 0, 0, 0, 0, 1, 78, 255, 254, 255, 255, 255, 254, 254, 255, 252, 255, 253, 255, 255, 255, 255, 155, 40, 1, 0, 0, 0, 0, 1, 0, 1, 53, 181, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255, 253, 253, 243, 166, 26, 4, 0, 0, 0, 0, 0, 0, 3, 0, 2, 29, 203, 203, 239, 255, 255, 254, 255, 254, 252, 255, 231, 210, 169, 3, 0, 0, 0, 2, 0, 0, 2, 0, 0, 3, 0, 0, 2, 0, 176, 252, 255, 255, 252, 255, 255, 255, 136, 0, 3, 0, 1, 1, 2, 0, 0, 0};
        
        char digit_7[30*26] = {0, 2, 0, 1, 0, 185, 255, 254, 254, 255, 255, 255, 255, 252, 255, 253, 255, 253, 255, 255, 253, 255, 253, 255, 168, 0, 0, 0, 1, 34, 172, 234, 255, 253, 255, 251, 255, 254, 255, 255, 255, 255, 255, 255, 252, 255, 255, 255, 253, 254, 227, 181, 2, 0, 0, 25, 121, 221, 252, 255, 255, 255, 252, 254, 253, 255, 252, 255, 255, 255, 254, 255, 252, 254, 255, 254, 255, 251, 78, 20, 1, 0, 2, 134, 180, 175, 177, 180, 182, 179, 189, 246, 255, 254, 255, 254, 255, 254, 255, 255, 255, 255, 254, 255, 226, 84, 1, 0, 0, 1, 0, 1, 3, 0, 0, 2, 24, 200, 229, 244, 253, 255, 255, 251, 255, 255, 250, 255, 255, 255, 26, 11, 0, 0, 1, 0, 0, 1, 0, 0, 3, 0, 3, 25, 24, 121, 255, 254, 251, 255, 253, 253, 255, 255, 254, 255, 2, 0, 1, 3, 0, 0, 1, 0, 0, 1, 0, 0, 3, 0, 0, 35, 111, 248, 255, 252, 255, 255, 254, 253, 192, 79, 0, 0, 0, 0, 2, 0, 3, 0, 1, 0, 2, 0, 0, 0, 1, 0, 48, 247, 253, 255, 255, 253, 255, 255, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 33, 109, 249, 255, 255, 255, 254, 254, 212, 119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 6, 0, 2, 105, 255, 255, 251, 253, 255, 252, 237, 98, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 0, 1, 0, 110, 255, 253, 255, 255, 253, 249, 70, 8, 1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 2, 1, 4, 0, 118, 209, 254, 255, 254, 253, 205, 74, 11, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 169, 255, 255, 255, 255, 252, 193, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 11, 66, 193, 254, 255, 255, 255, 218, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28, 226, 255, 255, 255, 255, 233, 113, 2, 0, 4, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 29, 228, 255, 253, 255, 253, 90, 12, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 62, 189, 245, 255, 254, 255, 255, 69, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 90, 253, 255, 255, 255, 230, 128, 35, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 89, 255, 254, 252, 255, 204, 15, 2, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 13, 106, 253, 255, 255, 243, 183, 11, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 132, 240, 255, 253, 255, 157, 23, 0, 3, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 148, 252, 255, 255, 251, 149, 0, 1, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 104, 199, 255, 252, 255, 255, 146, 2, 0, 1, 4, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 209, 253, 255, 255, 253, 205, 103, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 204, 254, 255, 254, 255, 90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 205, 255, 253, 255, 255, 83, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 209, 251, 255, 254, 255, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 205, 255, 254, 241, 141, 44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 140, 225, 228, 156, 23, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 147, 166, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        
        char digit_8[30*26] = {0, 0, 0, 0, 0, 2, 0, 35, 254, 255, 254, 254, 254, 255, 170, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 2, 0, 78, 217, 222, 255, 255, 255, 255, 255, 252, 243, 217, 194, 4, 2, 0, 0, 2, 2, 0, 0, 0, 0, 1, 0, 114, 194, 215, 255, 255, 253, 255, 253, 255, 255, 255, 254, 255, 250, 195, 25, 0, 0, 0, 0, 0, 0, 0, 2, 0, 117, 218, 254, 253, 255, 254, 255, 254, 255, 255, 255, 254, 255, 251, 252, 253, 34, 4, 0, 1, 0, 0, 0, 0, 2, 0, 184, 255, 255, 255, 255, 254, 252, 130, 116, 113, 195, 253, 255, 255, 255, 255, 152, 36, 0, 0, 2, 0, 0, 0, 0, 101, 212, 255, 254, 255, 253, 240, 138, 12, 0, 0, 78, 194, 253, 255, 253, 255, 255, 61, 0, 4, 0, 2, 0, 0, 1, 214, 253, 253, 255, 255, 230, 146, 0, 0, 2, 3, 0, 110, 255, 254, 255, 252, 255, 61, 4, 0, 0, 0, 0, 0, 0, 211, 255, 255, 254, 234, 145, 0, 0, 0, 0, 0, 1, 115, 255, 254, 254, 255, 253, 66, 0, 0, 1, 0, 0, 0, 0, 212, 255, 255, 255, 176, 26, 1, 0, 0, 0, 1, 0, 113, 255, 255, 255, 255, 221, 55, 0, 2, 0, 0, 0, 0, 2, 212, 255, 254, 251, 255, 198, 10, 0, 3, 0, 0, 8, 121, 250, 255, 252, 255, 34, 3, 0, 1, 0, 0, 0, 0, 0, 211, 254, 255, 255, 255, 253, 208, 0, 0, 1, 0, 133, 247, 255, 255, 255, 254, 31, 0, 1, 0, 2, 3, 0, 0, 0, 35, 190, 253, 255, 254, 255, 249, 213, 22, 0, 147, 241, 255, 255, 255, 255, 254, 40, 0, 0, 3, 0, 0, 0, 0, 1, 0, 182, 255, 255, 254, 255, 255, 254, 198, 192, 234, 248, 255, 253, 255, 236, 68, 7, 3, 0, 0, 0, 3, 0, 0, 0, 6, 60, 190, 253, 255, 250, 255, 255, 250, 255, 255, 255, 252, 254, 254, 248, 164, 24, 0, 3, 0, 3, 0, 0, 0, 2, 0, 2, 151, 255, 255, 255, 255, 255, 252, 255, 252, 251, 255, 253, 255, 255, 252, 35, 3, 0, 0, 3, 0, 0, 0, 1, 0, 84, 197, 254, 253, 255, 255, 252, 153, 141, 139, 206, 254, 255, 253, 255, 255, 135, 28, 1, 4, 0, 2, 0, 0, 1, 0, 184, 255, 255, 255, 231, 166, 166, 14, 1, 0, 92, 206, 255, 254, 254, 255, 255, 62, 1, 0, 1, 0, 0, 0, 0, 56, 196, 255, 255, 232, 143, 2, 0, 1, 1, 1, 1, 83, 211, 255, 255, 255, 253, 115, 23, 0, 1, 0, 0, 0, 2, 211, 255, 253, 254, 163, 0, 1, 0, 0, 1, 0, 0, 3, 71, 226, 255, 253, 255, 253, 93, 0, 0, 1, 0, 0, 0, 210, 255, 254, 251, 153, 0, 0, 3, 0, 2, 0, 3, 0, 1, 54, 255, 255, 254, 254, 92, 2, 0, 0, 0, 0, 1, 213, 252, 255, 136, 10, 1, 1, 0, 1, 0, 0, 1, 1, 0, 54, 255, 255, 254, 254, 92, 2, 0, 0, 0, 0, 0, 211, 255, 255, 132, 0, 0, 0, 1, 1, 1, 2, 0, 0, 2, 52, 255, 253, 255, 253, 93, 0, 0, 1, 0, 0, 3, 211, 254, 255, 220, 127, 0, 0, 0, 0, 0, 0, 0, 0, 64, 204, 255, 255, 253, 115, 23, 0, 1, 0, 0, 0, 0, 209, 255, 255, 255, 219, 124, 1, 2, 0, 0, 1, 0, 75, 194, 255, 254, 255, 255, 62, 1, 0, 1, 0, 0, 0, 0, 210, 255, 255, 252, 255, 226, 121, 0, 0, 0, 1, 76, 194, 253, 255, 254, 255, 133, 29, 0, 0, 0, 2, 0, 0, 0, 118, 223, 253, 255, 255, 253, 237, 116, 115, 115, 116, 192, 255, 255, 252, 255, 255, 36, 0, 3, 1, 2, 0, 0, 0, 1, 0, 117, 218, 255, 255, 255, 255, 253, 255, 253, 255, 255, 255, 254, 255, 246, 166, 22, 0, 0, 2, 0, 1, 0, 0, 0, 2, 0, 116, 218, 255, 255, 253, 255, 250, 255, 254, 255, 254, 232, 191, 174, 3, 0, 7, 0, 0, 3, 0, 0, 0, 0, 0, 2, 1, 105, 215, 217, 222, 255, 255, 223, 218, 216, 219, 145, 2, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 1, 0, 38, 252, 255, 53, 0, 0, 3, 0, 0, 0, 0, 0, 0, 2, 3, 0, 2, 0, 0};
        
        char digit_9[30*26] = {1, 0, 0, 2, 0, 0, 0, 218, 254, 255, 253, 255, 255, 255, 254, 255, 255, 255, 215, 2, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 64, 206, 202, 245, 255, 253, 255, 252, 254, 255, 254, 255, 252, 255, 247, 204, 31, 1, 0, 0, 0, 0, 0, 0, 0, 81, 193, 255, 255, 254, 255, 254, 188, 86, 87, 85, 85, 191, 255, 254, 255, 255, 37, 0, 3, 0, 0, 0, 1, 0, 0, 116, 255, 253, 252, 255, 255, 184, 73, 1, 0, 0, 3, 72, 182, 255, 252, 255, 154, 40, 3, 0, 0, 0, 0, 1, 5, 119, 253, 255, 254, 255, 184, 71, 0, 0, 0, 1, 0, 0, 70, 186, 253, 255, 255, 76, 0, 3, 0, 0, 0, 1, 39, 153, 255, 251, 255, 195, 59, 1, 0, 3, 0, 0, 0, 1, 0, 77, 255, 253, 252, 81, 0, 0, 0, 0, 0, 0, 158, 255, 255, 255, 255, 40, 0, 3, 0, 0, 5, 1, 1, 1, 1, 68, 227, 252, 255, 98, 15, 1, 0, 0, 1, 0, 158, 255, 254, 255, 252, 40, 0, 2, 1, 4, 0, 0, 1, 0, 0, 0, 40, 255, 253, 255, 119, 0, 0, 0, 2, 0, 158, 255, 255, 254, 255, 40, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 41, 255, 254, 255, 116, 0, 0, 0, 1, 0, 159, 254, 254, 255, 252, 37, 2, 0, 4, 1, 0, 0, 0, 3, 1, 57, 197, 253, 255, 254, 115, 4, 0, 0, 0, 1, 155, 255, 255, 253, 255, 44, 0, 3, 0, 0, 6, 0, 1, 0, 1, 82, 253, 254, 255, 255, 115, 0, 0, 0, 0, 2, 160, 253, 254, 253, 255, 37, 0, 2, 1, 0, 0, 1, 0, 1, 52, 160, 254, 255, 254, 252, 120, 0, 0, 0, 0, 0, 157, 255, 255, 255, 255, 109, 27, 0, 3, 2, 1, 0, 3, 53, 165, 254, 255, 255, 251, 255, 119, 0, 0, 0, 0, 1, 128, 222, 255, 255, 252, 255, 113, 24, 0, 0, 0, 2, 38, 174, 254, 254, 255, 253, 255, 253, 118, 0, 0, 0, 3, 0, 0, 120, 254, 255, 254, 254, 255, 126, 17, 18, 17, 18, 201, 255, 255, 255, 253, 255, 251, 245, 112, 0, 0, 0, 0, 1, 2, 117, 255, 254, 255, 255, 254, 248, 237, 237, 238, 239, 249, 255, 254, 255, 255, 255, 255, 89, 6, 2, 0, 0, 0, 0, 0, 26, 115, 253, 255, 254, 255, 255, 254, 255, 254, 255, 255, 253, 255, 255, 254, 254, 255, 81, 0, 1, 0, 0, 0, 2, 2, 0, 26, 112, 254, 255, 253, 255, 255, 250, 254, 255, 122, 88, 159, 255, 255, 255, 254, 74, 3, 0, 0, 0, 0, 0, 0, 0, 0, 17, 120, 119, 120, 120, 119, 120, 122, 122, 24, 0, 57, 160, 253, 255, 255, 79, 0, 1, 0, 0, 0, 2, 0, 3, 3, 0, 0, 0, 0, 1, 0, 1, 0, 0, 2, 0, 1, 74, 255, 255, 253, 77, 1, 0, 0, 0, 0, 4, 1, 2, 0, 0, 5, 0, 1, 0, 0, 1, 2, 0, 0, 2, 1, 79, 253, 255, 254, 79, 2, 0, 0, 0, 0, 0, 0, 0, 11, 32, 0, 0, 0, 0, 1, 2, 0, 0, 3, 0, 16, 102, 255, 251, 228, 65, 0, 0, 0, 0, 0, 2, 2, 0, 79, 216, 1, 1, 0, 1, 0, 1, 1, 2, 0, 1, 115, 255, 255, 254, 40, 0, 0, 0, 0, 0, 1, 0, 0, 106, 229, 251, 220, 33, 0, 0, 1, 0, 0, 0, 1, 135, 239, 252, 255, 255, 38, 0, 1, 1, 0, 0, 0, 1, 2, 116, 255, 255, 255, 198, 58, 0, 1, 0, 1, 0, 143, 230, 255, 255, 224, 71, 10, 1, 0, 0, 0, 0, 6, 0, 0, 117, 255, 255, 253, 253, 184, 155, 150, 154, 152, 150, 236, 253, 255, 209, 88, 0, 0, 1, 0, 5, 0, 0, 0, 1, 1, 63, 172, 255, 255, 255, 254, 253, 255, 255, 255, 254, 254, 255, 200, 93, 0, 2, 2, 0, 0, 0, 0, 0, 3, 0, 1, 2, 50, 182, 255, 253, 255, 253, 253, 255, 254, 255, 255, 199, 91, 2, 2, 0, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 32, 204, 205, 239, 255, 255, 239, 203, 206, 208, 77, 2, 0, 0, 3, 0, 5, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 2, 178, 255, 253, 198, 2, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0};
        
        vector<Mat> digits(9);
        
        digits[0] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[1] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[2] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[3] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[4] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[5] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[6] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[7] = cv::Mat(Size(26, 30), CV_8UC1);
        digits[8] = cv::Mat(Size(26, 30), CV_8UC1);
        for(int i = 0; i < 30*26; i++)
        {
            digits[0].data[i] = digit_1[i];
            digits[1].data[i] = digit_2[i];
            digits[2].data[i] = digit_3[i];
            digits[3].data[i] = digit_4[i];
            digits[4].data[i] = digit_5[i];
            digits[5].data[i] = digit_6[i];
            digits[6].data[i] = digit_7[i];
            digits[7].data[i] = digit_8[i];
            digits[8].data[i] = digit_9[i];
        }
        
        
        Mat image = imread(image_file, CV_LOAD_IMAGE_GRAYSCALE);
        cv::resize(image, image, Size(image.cols/4, image.rows/4));
        GaussianBlur(image, image, Size(5,5), 0);
        Mat thresholded_image;
        adaptiveThreshold(image, thresholded_image, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 7, 5);
        bitwise_not(thresholded_image, thresholded_image);
        Mat dilated_image;
        Mat element = (Mat_<uchar>(3,3) << 0,1,0,1,1,1,0,1,0);
        dilate(thresholded_image, dilated_image, element);
        //cv::imwrite("/sdcard/thresholded_image.jpg", dilated_image);
        
        // Use floodfill to idenify the borders
        int max = -1;
        Point maxPt;
        for(int i = 0; i < dilated_image.size().height; i++)
        {
            uchar *row = dilated_image.ptr(i);
            for(int j = 0; j < dilated_image.size().width; j++)
            {
                if(row[j] >= 128)
                {
                    int area = floodFill(dilated_image, Point(j, i), CV_RGB(0,0,64));
                    if(area > max)
                    {
                        max = area;
                        maxPt = Point(j,i);
                    }
                }
            }
        }
        
        floodFill(dilated_image, maxPt, CV_RGB(255,255,255));
        
        for(int i = 0; i < dilated_image.size().height; i++)
        {
            uchar *row = dilated_image.ptr(i);
            for(int j = 0; j < dilated_image.size().width; j++)
            {
                if(row[j] == 64 && i != maxPt.x && j != maxPt.y)
                {
                    floodFill(dilated_image, Point(j,i), CV_RGB(0,0,0));
                }
            }
        }
        
        Mat eroded_image, lined_image;
        erode(dilated_image, eroded_image, element);
        erode(dilated_image, lined_image, element);
        //cv::imwrite("/sdcard/eroded_image.jpg", dilated_image);
        
        // Detect the lines
        vector<Vec2f> lines;
        HoughLines(eroded_image, lines, 1, CV_PI/180, 200);
        mergeRelatedLines(&lines, lined_image); // Add this line
        for(int i=0;i<lines.size();i++)
        {
            drawLine(lines[i], eroded_image, CV_RGB(0,0,128));
        }
        
        
        // Detecting the extremes
        Vec2f topEdge = Vec2f(1000,1000);
        Vec2f bottomEdge = Vec2f(-1000,-1000);
        Vec2f leftEdge = Vec2f(1000,1000);    double leftXIntercept=100000;
        Vec2f rightEdge = Vec2f(-1000,-1000);        double rightXIntercept=0;
        for(int i=0;i<lines.size();i++)
        {
            
            Vec2f current = lines[i];
            
            float p=current[0];
            
            float theta=current[1];
            
            if(p==0 && theta==-100)
                continue;
            double xIntercept;
            xIntercept = p/cos(theta);
            if(theta>CV_PI*80/180 && theta<CV_PI*100/180)
            {
                if(p<topEdge[0])
                    
                    topEdge = current;
                
                if(p>bottomEdge[0])
                    bottomEdge = current;
            }
            else if(theta<CV_PI*10/180 || theta>CV_PI*170/180)
            {
                if(xIntercept>rightXIntercept)
                {
                    rightEdge = current;
                    rightXIntercept = xIntercept;
                }
                else if(xIntercept<=leftXIntercept)
                {
                    leftEdge = current;
                    leftXIntercept = xIntercept;
                }
            }
        }
        drawLine(topEdge, lined_image, CV_RGB(0,0,0));
        drawLine(bottomEdge, lined_image, CV_RGB(0,0,0));
        drawLine(leftEdge, lined_image, CV_RGB(0,0,0));
        drawLine(rightEdge, lined_image, CV_RGB(0,0,0));
        
        Point left1, left2, right1, right2, bottom1, bottom2, top1, top2;
        
        int height=lined_image.size().height;
        
        int width=lined_image.size().width;
        
        if(leftEdge[1]!=0)
        {
            left1.x=0;        left1.y=leftEdge[0]/sin(leftEdge[1]);
            left2.x=width;    left2.y=-left2.x/tan(leftEdge[1]) + left1.y;
        }
        else
        {
            left1.y=0;        left1.x=leftEdge[0]/cos(leftEdge[1]);
            left2.y=height;    left2.x=left1.x - height*tan(leftEdge[1]);
            
        }
        
        if(rightEdge[1]!=0)
        {
            right1.x=0;        right1.y=rightEdge[0]/sin(rightEdge[1]);
            right2.x=width;    right2.y=-right2.x/tan(rightEdge[1]) + right1.y;
        }
        else
        {
            right1.y=0;        right1.x=rightEdge[0]/cos(rightEdge[1]);
            right2.y=height;    right2.x=right1.x - height*tan(rightEdge[1]);
            
        }
        
        bottom1.x=0;    bottom1.y=bottomEdge[0]/sin(bottomEdge[1]);
        
        bottom2.x=width;bottom2.y=-bottom2.x/tan(bottomEdge[1]) + bottom1.y;
        
        top1.x=0;        top1.y=topEdge[0]/sin(topEdge[1]);
        top2.x=width;    top2.y=-top2.x/tan(topEdge[1]) + top1.y;
        
        // Next, we find the intersection of  these four lines
        double leftA = left2.y-left1.y;
        double leftB = left1.x-left2.x;
        
        double leftC = leftA*left1.x + leftB*left1.y;
        
        double rightA = right2.y-right1.y;
        double rightB = right1.x-right2.x;
        
        double rightC = rightA*right1.x + rightB*right1.y;
        
        double topA = top2.y-top1.y;
        double topB = top1.x-top2.x;
        
        double topC = topA*top1.x + topB*top1.y;
        
        double bottomA = bottom2.y-bottom1.y;
        double bottomB = bottom1.x-bottom2.x;
        
        double bottomC = bottomA*bottom1.x + bottomB*bottom1.y;
        
        // Intersection of left and top
        double detTopLeft = leftA*topB - leftB*topA;
        
        CvPoint ptTopLeft = cvPoint((topB*leftC - leftB*topC)/detTopLeft, (leftA*topC - topA*leftC)/detTopLeft);
        
        // Intersection of top and right
        double detTopRight = rightA*topB - rightB*topA;
        
        CvPoint ptTopRight = cvPoint((topB*rightC-rightB*topC)/detTopRight, (rightA*topC-topA*rightC)/detTopRight);
        
        // Intersection of right and bottom
        double detBottomRight = rightA*bottomB - rightB*bottomA;
        CvPoint ptBottomRight = cvPoint((bottomB*rightC-rightB*bottomC)/detBottomRight, (rightA*bottomC-bottomA*rightC)/detBottomRight);// Intersection of bottom and left
        double detBottomLeft = leftA*bottomB-leftB*bottomA;
        CvPoint ptBottomLeft = cvPoint((bottomB*leftC-leftB*bottomC)/detBottomLeft, (leftA*bottomC-bottomA*leftC)/detBottomLeft);
        
        int maxLength = (ptBottomLeft.x-ptBottomRight.x)*(ptBottomLeft.x-ptBottomRight.x) + (ptBottomLeft.y-ptBottomRight.y)*(ptBottomLeft.y-ptBottomRight.y);
        int temp = (ptTopRight.x-ptBottomRight.x)*(ptTopRight.x-ptBottomRight.x) + (ptTopRight.y-ptBottomRight.y)*(ptTopRight.y-ptBottomRight.y);
        
        if(temp>maxLength) maxLength = temp;
        
        temp = (ptTopRight.x-ptTopLeft.x)*(ptTopRight.x-ptTopLeft.x) + (ptTopRight.y-ptTopLeft.y)*(ptTopRight.y-ptTopLeft.y);
        
        if(temp>maxLength) maxLength = temp;
        
        temp = (ptBottomLeft.x-ptTopLeft.x)*(ptBottomLeft.x-ptTopLeft.x) + (ptBottomLeft.y-ptTopLeft.y)*(ptBottomLeft.y-ptTopLeft.y);
        
        if(temp>maxLength) maxLength = temp;
        
        maxLength = sqrt((double)maxLength);
        
        Point2f src[4], dst[4];
        src[0] = ptTopLeft;            dst[0] = Point2f(0,0);
        src[1] = ptTopRight;        dst[1] = Point2f(maxLength-1, 0);
        src[2] = ptBottomRight;        dst[2] = Point2f(maxLength-1, maxLength-1);
        src[3] = ptBottomLeft;        dst[3] = Point2f(0, maxLength-1);
        
        // Warp the image
        
        Mat undistorted = Mat(Size(maxLength, maxLength), CV_8UC1);
        cv::warpPerspective(image, undistorted, cv::getPerspectiveTransform(src, dst), Size(maxLength, maxLength));
        
        //cv::imwrite("/sdcard/undistorted.jpg", undistorted);
        // Now repeat the floodfill to identify and remove the borderes. Then we are left with only numbers. It hepls with the accuracy.
        Mat undistortedThreshed = undistorted.clone();
        adaptiveThreshold(undistorted, undistortedThreshed, 255, CV_ADAPTIVE_THRESH_GAUSSIAN_C, CV_THRESH_BINARY_INV, 101, 1);
        erode(undistortedThreshed, undistortedThreshed, element);
        
        
        dilate(undistortedThreshed, dilated_image, element);
        
        max = -1;
        for(int i = 0; i < dilated_image.size().height; i++)
        {
            uchar *row = dilated_image.ptr(i);
            for(int j = 0; j < dilated_image.size().width; j++)
            {
                if(row[j] >= 128)
                {
                    int area = floodFill(dilated_image, Point(j, i), CV_RGB(0,0,64));
                    if(area > max)
                    {
                        max = area;
                        maxPt = Point(j,i);
                    }
                }
            }
        }
        
        floodFill(dilated_image, maxPt, CV_RGB(255,255,255));
        
        for(int i = 0; i < dilated_image.size().height; i++)
        {
            uchar *row = dilated_image.ptr(i);
            for(int j = 0; j < dilated_image.size().width; j++)
            {
                if(row[j] == 64 && i != maxPt.x && j != maxPt.y)
                {
                    floodFill(dilated_image, Point(j,i), CV_RGB(0,0,0));
                }
            }
        }
        
        erode(dilated_image, eroded_image, element);
        
        undistortedThreshed = undistortedThreshed - eroded_image;
        erode(undistortedThreshed, undistortedThreshed, element);
        //dilate(undistortedThreshed, undistortedThreshed, element);
        
        Mat resized = Mat(Size((undistortedThreshed.cols/9)*9, (undistortedThreshed.rows/9)*9), CV_8UC1);
        cv::resize(undistortedThreshed, resized, Size((undistortedThreshed.cols/9)*9, (undistortedThreshed.rows/9)*9));
        //cv::imwrite("/sdcard/resized.jpg", resized);
        
        
        // Split the image into 81 parts, so as to identify the numbers.
        for(int i = 0; i < 9; i++)
        {
            for(int j = 0; j < 9; j++)
            {
                puzzle[i][j] = 0;
                Mat cell = Mat(Size(resized.cols/9, resized.rows/9), CV_8UC1);
                for(int ii = 0; ii < cell.rows; ii++)
                {
                    for(int jj = 0; jj < cell.cols; jj++)
                    {
                        cell.data[ii*cell.cols+jj] = resized.data[i*cell.rows*resized.cols + ii*resized.cols + jj + j*cell.cols];
                    }
                }
                
                int area = countNonZero(cell);
                if(area < cell.rows * cell.cols / 24)
                {
                    //LOG(INFO) << "i = " << i << " j = " << j << " area = " << area << " " << cell.rows * cell.cols / 24;
                    continue;
                }
                
                // Save the cell as an image to make an inference later using Caffe
                cv::resize(cell, cell, Size(28,28));
                cv::imwrite("/sdcard/cell.jpg", cell);

                
 /*               // Get datum
                Datum datum;
                if (!ReadImageToDatum("data/cell.jpg", 1, 28, 28, false, &datum)) {
                    LOG(ERROR) << "Error during file reading";
                }
                
                
                // Get the blob
                Blob<float>* blob = new Blob<float>(1, datum.channels(), datum.height(), datum.width());
                
                // Get the blobproto
                BlobProto blob_proto;
                blob_proto.set_num(1);
                blob_proto.set_channels(datum.channels());
                blob_proto.set_height(datum.height());
                blob_proto.set_width(datum.width());
                int size_in_datum = std::max<int>(datum.data().size(),
                                                  datum.float_data_size());
                
                for (int ii = 0; ii < size_in_datum; ++ii) {
                    blob_proto.add_data(0.);
                }
                const string& data = datum.data();
                if (data.size() != 0) {
                    for (int ii = 0; ii < size_in_datum; ++ii) {
                        blob_proto.set_data(ii, blob_proto.data(ii) + (uint8_t)data[ii]);
                    }
                }
                
                // Set data into blob
                blob->FromProto(blob_proto);
                
                // Fill the vector
                vector<Blob<float>*> bottom;
                bottom.push_back(blob);
                float type = 0.0;
*/
                const vector<float> result =  Forward("/sdcard/cell.jpg");
                
                // Here I can use the argmax layer, but for now I do a simple for loop
                float max = 0;
                float max_i = 0;
                for (int ii = 0; ii < 10; ++ii) {
                    float value = result[ii];
                    if (max < value){
                        max = value;
                        max_i = ii;
                    }
                    //LOG(INFO) << "i = " << ii << "prob = " << value;
                }

                //LOG(INFO) << "max = " << max << " max_i = " << max_i;
                
                // Condition to detemine if the cell contains a digit or not.
                if(max > 0.90)
                    puzzle[i][j] = max_i;
            }
        }
        LOG(INFO) << "Completed puzzle\n";
        int possible = solve(puzzle);
        if(possible) {
        for(int i = 0; i < 9; i++)
        {
            cv::resize(digits[i], digits[i], Size(resized.cols/9, resized.rows/9));
        }
        LOG(INFO) << "Resized\n";
        
        for(int i = 0; i < 9; i++)
        {
            for(int j = 0; j < 9; j++)
            {
                for(int ii = 0; ii < resized.rows/9; ii++)
                {
                    for(int jj = 0; jj < resized.cols/9; jj++)
                    {
                        resized.data[i*(resized.rows/9)*resized.cols + ii*resized.cols + jj + j*(resized.cols/9)] = digits[puzzle[i][j]-1].data[ii*resized.cols/9+jj];
                    }
                }
            }
        }
            cv::imwrite("/sdcard/sudoku_final.jpg", resized);
        }
        return possible;
    }


template <typename T> vector<int> argmax(vector<T> const &values, int N) {
  vector<size_t> indices(values.size());
  std::iota(indices.begin(), indices.end(), static_cast<size_t>(0));
  std::partial_sort(indices.begin(), indices.begin() + N, indices.end(),
                    [&](size_t a, size_t b) { return values[a] > values[b]; });
  return vector<int>(indices.begin(), indices.begin() + N);
}

CaffeMobile *CaffeMobile::caffe_mobile_ = 0;
string CaffeMobile::model_path_ = "";
string CaffeMobile::weights_path_ = "";

CaffeMobile *CaffeMobile::Get() {
  CHECK(caffe_mobile_);
  return caffe_mobile_;
}

CaffeMobile *CaffeMobile::Get(const string &model_path,
                              const string &weights_path) {
  if (!caffe_mobile_ || model_path != model_path_ ||
      weights_path != weights_path_) {
    caffe_mobile_ = new CaffeMobile(model_path, weights_path);
    model_path_ = model_path;
    weights_path_ = weights_path;
  }
  return caffe_mobile_;
}

CaffeMobile::CaffeMobile(const string &model_path, const string &weights_path) {
  CHECK_GT(model_path.size(), 0) << "Need a model definition to score.";
  CHECK_GT(weights_path.size(), 0) << "Need model weights to score.";

  Caffe::set_mode(Caffe::CPU);

  clock_t t_start = clock();
  net_.reset(new Net<float>(model_path, caffe::TEST));
  net_->CopyTrainedLayersFrom(weights_path);
  clock_t t_end = clock();
  LOG(INFO) << "Loading time: " << 1000.0 * (t_end - t_start) / CLOCKS_PER_SEC
            << " ms.";

  CHECK_EQ(net_->num_inputs(), 1) << "Network should have exactly one input.";
  CHECK_EQ(net_->num_outputs(), 1) << "Network should have exactly one output.";

  Blob<float> *input_layer = net_->input_blobs()[0];
  num_channels_ = input_layer->channels();
  CHECK(num_channels_ == 3 || num_channels_ == 1)
      << "Input layer should have 1 or 3 channels.";
  input_geometry_ = cv::Size(input_layer->width(), input_layer->height());

  scale_ = 0.0;
}

CaffeMobile::~CaffeMobile() { net_.reset(); }

void CaffeMobile::SetMean(const vector<float> &mean_values) {
  CHECK_EQ(mean_values.size(), num_channels_)
      << "Number of mean values doesn't match channels of input layer.";

  cv::Scalar channel_mean(0);
  double *ptr = &channel_mean[0];
  for (int i = 0; i < num_channels_; ++i) {
    ptr[i] = mean_values[i];
  }
  mean_ = cv::Mat(input_geometry_, (num_channels_ == 3 ? CV_32FC3 : CV_32FC1),
                  channel_mean);
}

void CaffeMobile::SetMean(const string &mean_file) {
  BlobProto blob_proto;
  ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);

  /* Convert from BlobProto to Blob<float> */
  Blob<float> mean_blob;
  mean_blob.FromProto(blob_proto);
  CHECK_EQ(mean_blob.channels(), num_channels_)
      << "Number of channels of mean file doesn't match input layer.";

  /* The format of the mean file is planar 32-bit float BGR or grayscale. */
  std::vector<cv::Mat> channels;
  float *data = mean_blob.mutable_cpu_data();
  for (int i = 0; i < num_channels_; ++i) {
    /* Extract an individual channel. */
    cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
    channels.push_back(channel);
    data += mean_blob.height() * mean_blob.width();
  }

  /* Merge the separate channels into a single image. */
  cv::Mat mean;
  cv::merge(channels, mean);

  /* Compute the global mean pixel value and create a mean image
   * filled with this value. */
  cv::Scalar channel_mean = cv::mean(mean);
  mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
}

void CaffeMobile::SetScale(const float scale) {
  CHECK_GT(scale, 0);
  scale_ = scale;
}

void CaffeMobile::Preprocess(const cv::Mat &img,
                             std::vector<cv::Mat> *input_channels) {
  /* Convert the input image to the input image format of the network. */
  cv::Mat sample;
  if (img.channels() == 3 && num_channels_ == 1)
    cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
  else if (img.channels() == 4 && num_channels_ == 1)
    cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
  else if (img.channels() == 4 && num_channels_ == 3)
    cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
  else if (img.channels() == 1 && num_channels_ == 3)
    cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
  else
    sample = img;

  cv::Mat sample_resized;
  if (sample.size() != input_geometry_)
    cv::resize(sample, sample_resized, input_geometry_);
  else
    sample_resized = sample;

  cv::Mat sample_float;
  if (num_channels_ == 3)
    sample_resized.convertTo(sample_float, CV_32FC3);
  else
    sample_resized.convertTo(sample_float, CV_32FC1);

  cv::Mat sample_normalized;
  if (!mean_.empty()) {
    cv::subtract(sample_float, mean_, sample_normalized);
  } else {
    sample_normalized = sample_float;
  }

  if (scale_ > 0.0) {
    sample_normalized *= scale_;
  }

  /* This operation will write the separate BGR planes directly to the
   * input layer of the network because it is wrapped by the cv::Mat
   * objects in input_channels. */
  cv::split(sample_normalized, *input_channels);

  CHECK(reinterpret_cast<float *>(input_channels->at(0).data) ==
        net_->input_blobs()[0]->cpu_data())
      << "Input channels are not wrapping the input layer of the network.";
}

void CaffeMobile::WrapInputLayer(std::vector<cv::Mat> *input_channels) {
  Blob<float> *input_layer = net_->input_blobs()[0];

  int width = input_layer->width();
  int height = input_layer->height();
  float *input_data = input_layer->mutable_cpu_data();
  for (int i = 0; i < input_layer->channels(); ++i) {
    cv::Mat channel(height, width, CV_32FC1, input_data);
    input_channels->push_back(channel);
    input_data += width * height;
  }
}

vector<float> CaffeMobile::Forward(const string &filename) {
  cv::Mat img = cv::imread(filename, -1);
  CHECK(!img.empty()) << "Unable to decode image " << filename;

  Blob<float> *input_layer = net_->input_blobs()[0];
  input_layer->Reshape(1, num_channels_, input_geometry_.height,
                       input_geometry_.width);
  /* Forward dimension change to all layers. */
  net_->Reshape();

  vector<cv::Mat> input_channels;
  WrapInputLayer(&input_channels);

  Preprocess(img, &input_channels);

  clock_t t_start = clock();
  net_->Forward();
  clock_t t_end = clock();
  LOG(INFO) << "Forwarding time: " << 1000.0 * (t_end - t_start) / CLOCKS_PER_SEC
            << " ms.";

  /* Copy the output layer to a std::vector */
  Blob<float> *output_layer = net_->output_blobs()[0];
  const float *begin = output_layer->cpu_data();
  const float *end = begin + output_layer->channels();
  return vector<float>(begin, end);
}

vector<float> CaffeMobile::GetConfidenceScore(const string &img_path) {
  return Forward(img_path);
}

vector<int> CaffeMobile::PredictTopK(const string &img_path, int k) {
    vector<int> result;
    
    int **sudoku = (int **) malloc(sizeof(int *) * 9);
    for(int i = 0; i < 9; i++)
    {
        sudoku[i] = (int *) malloc(sizeof(int) * 9);
    }
    
    int possible = getImage(img_path, sudoku);
    // Print puzzle
    
    for(int i = 0; i < 9; i++)
    {
        for(int j = 0; j < 9; j++)
        {
            if(sudoku[i][j] == 0) {
                printf("   |");
                LOG(INFO) << "   |";
            }
            else {
                printf(" %d |", sudoku[i][j]);
                LOG(INFO) << " " << sudoku[i][j] << " |";
            }
            
        }
        printf("\n");
    }
    
    result.push_back(possible);
    
    if(possible)
    {
        printf("\nSolved sudoku:\n");
        for(int i = 0; i < 9; i++)
        {
            for(int j = 0; j < 9; j++)
            {
                if(sudoku[i][j] == 0) {
                    printf("   |");
                    LOG(INFO) << "   |";
                }
                else {
                    printf(" %d |", sudoku[i][j]);
                    LOG(INFO) << " " << sudoku[i][j] << " |";
                }
                
            }
            printf("\n");
        }
    }
    else
    {
        printf("Not possible\n");
        LOG(INFO) << "Not possible\n";
    }
    //return 0;
  //const vector<float> probs = Forward(img_path);
  //k = std::min<int>(std::max(k, 1), probs.size());
  //return argmax(probs, k);
    return result;
}

vector<vector<float>>
CaffeMobile::ExtractFeatures(const string &img_path,
                             const string &str_blob_names) {
  Forward(img_path);

  vector<std::string> blob_names;
  boost::split(blob_names, str_blob_names, boost::is_any_of(","));

  size_t num_features = blob_names.size();
  for (size_t i = 0; i < num_features; i++) {
    CHECK(net_->has_blob(blob_names[i])) << "Unknown feature blob name "
                                         << blob_names[i];
  }

  vector<vector<float>> features;
  for (size_t i = 0; i < num_features; i++) {
    const shared_ptr<Blob<float>> &feat = net_->blob_by_name(blob_names[i]);
    features.push_back(
        vector<float>(feat->cpu_data(), feat->cpu_data() + feat->count()));
  }

  return features;
}

} // namespace caffe

using caffe::CaffeMobile;

int main(int argc, char const *argv[]) {
  string usage("usage: main <model> <weights> <mean_file> <img>");
  if (argc < 5) {
    std::cerr << usage << std::endl;
    return 1;
  }

  CaffeMobile *caffe_mobile =
      CaffeMobile::Get(string(argv[1]), string(argv[2]));
  caffe_mobile->SetMean(string(argv[3]));
  vector<int> top_3 = caffe_mobile->PredictTopK(string(argv[4]), 3);
  for (auto i : top_3) {
    std::cout << i << std::endl;
  }
  return 0;
}
